Паттерны:
1) Паттерн Наблюдатель - при обновлении объекта, оповещаются все зависимые от него объекты.
2) Паттерн Декоратор - динамически наделяет объект новыми возможностями и является гибкой альтернативой субклассированию.
3) Паттерн Шаблонный Метод - позволяет создавать метод шаблон, который реализует некий алгоритм, методы алгоритма
можно переопределять (не все), с помощью перехватчика можно опускать нектороые части алгоритма.
4) Паттерн Итератор - предоставляет механизм последовательного перебора элементов
коллекции без раскрытия ее внутреннего представления.
5) Паттерн Стратегия - Определяет семейство алгоритмов, инкапсулирует каждый из них и обеспечивает их взаимозаменяемость.
Позволяет модифицировать алгоритмы не зависимо от их использования на стороне клиента.
6) Паттерн Фасад - Паттерн Фасад предоставлять унифицированный интерфейс к группе интерфейсов подсистемы.
Фасад определяет высоко - уровневый интерфейс, упрощающий работу с подсистемой.
7) Паттерн Адаптер - преобразует интерфейс класса к другому интерфейсу, на который рассчитан клиент.
Адаптер обеспечивает совметсную работу классов, невозможную в обычных условиях из-за несовместимости интерфейсов.
8) Паттерн Команда - инкапсулирует запрос в виде объекта, делая возможным параметризацию клиентских объектов
с другими запросами, организацию очереди или регистрацию запросов, а так же поддержку отмены операций.
9)  Паттерн Фабричный Метод - определяет интерфейс создания объекта, но позволяет субклассам выбрать класс создаваемого
экземпляра. Таким образом, фабричный метод делегирует операцию создания экземпляра субкласса.
10) Абстрактная Фабрика - предоставляет интерфейс создания семейства взаимосвязанных и взаимозависимых объектов
без указания их конкретных классов.
11) Паттерн одиночка - гарантирует, что класс имеет только один экземпляр, и предоставляет глобальную точку доступа к этому экземпляру.

Принципы:
1. Инкапсулируйте то, что изменяется.
2. Предпочитайте композицию наследованию.
3. Программируйте на уровне интерфейсов.
4. Стремитесь к слабой связанности взаимодействующих объектов.
5. Классы должны быть открыты для расширения, но закрыты для изменения.
6. Код должен зависеть от абстракции, а не от конкретных классов.
7. Взаимодействуйте только с "друзьями". (т.е. такие вещи недопустимы - station.getThermometer.getTemperature())
8. Не вызывайте нас - мы вас сами вызовем.
9. Класс долже иметь тольк одну причину для изменения. (т.е. класс должен иметь одну обязанность, а не несколько, т.к.
несколько обязанностей - несколько причин для изменения)
