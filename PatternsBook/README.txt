Паттерны:

1) Паттерн Наблюдатель - Издатели + Подписчики. Определяет отношение «один-ко-многим» между объектами таким образом, 
что при изменении состояния одного объекта происходит автоматическое оповещение и обновление всех зависимых объектов.

2) Паттерн Декоратор - динамически наделяет объект новыми возможностями и является гибкой альтернативой субклассированию в области расширения функциональности.

3) Паттерн Шаблонный Метод - позволяет создавать метод шаблон, который реализует некий алгоритм, методы алгоритма можно переопределять (не все), с помощью перехватчика можно опускать нектороые части алгоритма.

4) Паттерн Итератор - предоставляет механизм последовательного перебора элементов коллекции без раскрытия ее внутреннего представления.

5) Паттерн Стратегия - Определяет семейство алгоритмов, инкапсулирует каждый из них и обеспечивает их взаимозаменяемость. Позволяет модифицировать алгоритмы не зависимо от их использования на стороне клиента.

6) Паттерн Фасад - Паттерн Фасад предоставлять унифицированный интерфейс к группе интерфейсов подсистемы. Фасад определяет высоко - уровневый интерфейс, упрощающий работу с подсистемой.

7) Паттерн Адаптер - преобразует интерфейс класса к другому интерфейсу, на который рассчитан клиент. Адаптер обеспечивает совметсную работу классов, невозможную в обычных условиях из-за несовместимости интерфейсов.

8) Паттерн Команда - инкапсулирует запрос в виде объекта, делая возможным параметризацию клиентских объектов с другими запросами, организацию очереди или регистрацию запросов, а так же поддержку отмены операций.

9)  Паттерн Фабричный Метод - определяет интерфейс создания объекта, но позволяет субклассам выбрать класс создаваемого экземпляра. Таким образом, фабричный метод делегирует операцию создания экземпляра субкласса.

10) Абстрактная Фабрика - предоставляет интерфейс создания семейства взаимосвязанных и взаимозависимых объектов без указания их конкретных классов.

11) Паттерн одиночка - гарантирует, что класс имеет только один экземпляр, и предоставляет глобальную точку доступа к этому экземпляру.

12) Паттерн Компановщик объединяет объекты в древовидные структуры для представления иерархий "часть/целое". Компоновщик позволяет клиенту выполнять однородные операции с отдельными объектами и их совокупностями.

13) Паттерн Состояние - управляет изменением поведения объекта при изменении его внутреннего состояния.
Внешне это выглядит так, словно объект меняет свой класс.

Принципы:

1. Инкапсулируйте то, что изменяется.

2. Отдавайте предпочтение композиции (делегирование) перед наследованием. 
(расширяемо, !зависимости от реализации)

3. Программируй на уровне интерфейсов (не JAVA интерфейс, а супертип), 
а не на уровне реализации. (!зависимости от реализации)

4. Стремитесь к слабой связанности взаимодействующих объектов.

5. Классы должны быть открыты для расширения, но закрыты для изменения.

6. Код должен зависеть от абстракции, а не от конкретных классов.

7. Взаимодействуйте только с "друзьями". (т.е. такие вещи недопустимы - station.getThermometer.getTemperature())

8. Не вызывайте нас - мы вас сами вызовем. (т.е. компоненты высокого уровня сами вызывают компоненты низкого уровня. Пример реализации принципа - шаблонный метод, где класс высокого уровня через шаблонный метод управляет компонентами низкого уровня. Компоненты низкого уровня обращаются к компоненте высокого уровня не на прямую.)

9. Класс долже иметь тольк одну причину для изменения. (т.е. класс должен иметь одну обязанность, а не несколько, т.к. несколько обязанностей - несколько причин для изменения)

10. Выделение из объекта аспектов приложения, которые могут изменятся, и отделяем их от тех, которые всегда остаются постоянными - ИНКАПСУЛЯЦИЯ (Аля поведение, имеющей различные реализации, из класса выносим и выделяем его как интерфейс)

